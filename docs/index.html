<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpectralCloth - Fabric simulation and volume rendering system</title>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: true
            }
        };
    </script>
    <script id="MathJax-script" async src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            box-shadow: 0 0 30px rgba(0,0,0,0.1);
            border-radius: 15px;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        header {
            text-align: center;
            padding: 60px 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px 15px 0 0;
            margin: -20px -20px 30px -20px;
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="white" opacity="0.1"/><circle cx="75" cy="75" r="1" fill="white" opacity="0.1"/><circle cx="50" cy="10" r="0.5" fill="white" opacity="0.1"/><circle cx="10" cy="60" r="0.5" fill="white" opacity="0.1"/><circle cx="90" cy="40" r="0.5" fill="white" opacity="0.1"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
            pointer-events: none;
        }

        h1 {
            font-size: 3.2em;
            margin-bottom: 15px;
            text-shadow: 0 4px 8px rgba(0,0,0,0.3);
            font-weight: 700;
            letter-spacing: -0.5px;
            position: relative;
            z-index: 1;
        }

        .subtitle {
            font-size: 1.3em;
            opacity: 0.95;
            margin-bottom: 30px;
            font-weight: 300;
            position: relative;
            z-index: 1;
        }
        
        .project-links {
            margin-top: 30px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            position: relative;
            z-index: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .project-links p {
            margin: 0;
            font-size: 1em;
            color: white;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .project-links strong {
            font-weight: 600;
            min-width: 100px;
            text-align: right;
            flex-shrink: 0;
        }
        
        .project-links a {
            color: #ffd700;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
            padding: 8px 16px;
            border-radius: 6px;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .project-links a:hover {
            color: #fff;
            background: rgba(255, 215, 0, 0.2);
            border-color: rgba(255, 215, 0, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
        }

        section {
            margin: 40px 0;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        h2 {
            color: #667eea;
            font-size: 1.8em;
            margin-bottom: 20px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        h3 {
            color: #555;
            font-size: 1.4em;
            margin: 25px 0 15px 0;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        .highlight {
            background: linear-gradient(120deg, #a8edea 0%, #fed6e3 100%);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }

        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 15px 0;
        }
        
        .formula-block {
            background: #f0f8ff;
            border-left: 4px solid #28a745;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            font-family: 'Times New Roman', serif;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .formula-block div {
            margin: 10px 0;
        }
        
        .formula-block .MathJax {
            font-size: 1.1em;
        }
        
        .formula-block h5 {
            color: #28a745;
            margin-top: 0;
            font-weight: bold;
        }
        
        .formula-block p {
            margin: 10px 0;
            font-size: 16px;
        }
        
        .formula-block strong {
            color: #007bff;
        }
        
        .spring-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .spring-type {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .spring-type h5 {
            color: #856404;
            margin-top: 0;
            font-weight: bold;
        }
        
        .spring-type p {
            margin: 8px 0;
            color: #6c757d;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .feature-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-top: 4px solid #667eea;
        }

        .demo-placeholder {
            background: linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                        linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #f0f0f0 75%), 
                        linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            margin: 20px 0;
            border: 2px dashed #667eea;
        }

        .demo-placeholder h4 {
            color: #667eea;
            font-size: 1.2em;
        }
        
        .demo-video {
            margin: 20px 0;
            text-align: center;
        }
        
        .demo-video h4 {
            color: #667eea;
            font-size: 1.2em;
            margin-bottom: 15px;
        }
        
        .demo-video video {
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 2px solid #667eea;
        }

        .tech-stack {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }

        .tech-tag {
            background: #667eea;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
        }
        
        .results-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
        }

        .result-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: center;
        }

        .team-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin: 30px 0;
        }

        .team-member {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .references {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .references ol {
            margin-left: 20px;
        }

        .references li {
            margin-bottom: 10px;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #666;
            border-top: 1px solid #eee;
            margin-top: 40px;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 15px;
            }
            
            header {
                padding: 40px 20px;
            }
            
            h1 {
                font-size: 2.2em;
                letter-spacing: -0.3px;
            }
            
            .subtitle {
                font-size: 1.1em;
            }
            
            .project-links {
                padding: 20px;
                margin-top: 20px;
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .project-links p {
                flex-direction: column;
                gap: 8px;
                align-items: center;
            }
            
            .project-links strong {
                min-width: auto;
                text-align: center;
                margin-bottom: 2px;
            }
            
            .feature-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Cloth Simulation with Ray Marching Volume Rendering and collision detection</h1>
            
            <div class="project-links">
                <p><strong>Webpage:</strong><a href="https://cal-cs184.github.io/ggbond-final-project/" target="_blank">Webpage</a></p>
                <p><strong>Demo Video:</strong><a href="https://drive.google.com/file/d/1FCitWz1yYilSj30fi_XJVgfw1Sk6cbxS/view?usp=sharing" target="_blank">Demo Video</a></p>
                <p><strong>Slides:</strong><a href="https://docs.google.com/presentation/d/13iMc528H9VURbBB-L8lEzaiBUMRKlWE6tD9pN5pahIQ/edit?usp=sharing" target="_blank">Presentation Slides</a></p>
                <p><strong>GitHub:</strong><a href="https://github.com/cal-cs184/ggbond-final-project" target="_blank">GitHub Repository</a></p>
            </div>
        </header>

        <section>
            
            <h2>Abstract</h2>
            <p>This project implements the integration of cloth physics simulation with ray marching volume rendering and collision detection. 
                Based on the CS184 Assignment 4 mass-spring cloth simulation framework, creating realistic volume effects in ray marching rendering.</p>
            
            <div class="highlight">
                <strong>Core Innovation:</strong> Using ray marching for collision detection with SDF (Signed Distance Field) objects, 
                eliminating the need for traditional mesh-based collision detection. This approach leverages the same ray marching 
                algorithm for both volume rendering and collision detection, providing a unified framework for cloth-SDF object interactions.
                 We implemented comparison of three collision detection methods: basic collision, continuous collision detection (CCD), and ray marching collision with SDF objects, validating the robustness of different approaches under 100x gravity environment.
            </div>
        </section>

        <section>
            <h2>Technical Approach</h2>
            
                          <h3>Basic: Quality-Spring physical Simulation</h3>
              <p>Based on the CS184 assignment 4 framework, we implement complete fabric physics simulation with structural springs, shearing springs, and bending springs.</p>
              
              <h4>Spring Force Calculation Formula</h4>
              <div class="formula-block">
                  <h5>Hooke's Law</h5>
                  <p><strong>Spring Force:</strong></p>
                  <div style="text-align: center; margin: 15px 0;">
                      $$\mathbf{F} = -k(\mathbf{x} - \mathbf{x}_0)$$
                  </div>
                  <ul>
                      <li>$\mathbf{F}$: Spring force vector</li>
                      <li>$k$: Spring stiffness coefficient</li>
                      <li>$\mathbf{x}$: Current spring length</li>
                      <li>$\mathbf{x}_0$: Spring natural length</li>
                  </ul>
              </div>
              
              <div class="formula-block">
                  <h5>Damping Force</h5>
                  <p><strong>Damping Force:</strong></p>
                  <div style="text-align: center; margin: 15px 0;">
                      $$\mathbf{F}_d = -c(\mathbf{v}_1 - \mathbf{v}_2)$$
                  </div>
                  <ul>
                      <li>$\mathbf{F}_d$: Damping force vector</li>
                      <li>$c$: Damping coefficient</li>
                      <li>$\mathbf{v}_1, \mathbf{v}_2$: Two particle velocity vectors</li>
                  </ul>
              </div>
              
              <div class="formula-block">
                  <h5>Total Spring Force</h5>
                  <p><strong>Total Force:</strong></p>
                  <div style="text-align: center; margin: 15px 0;">
                      $$\mathbf{F}_{total} = \mathbf{F}_{spring} + \mathbf{F}_{damping}$$
                      $$\mathbf{F}_{total} = -k(\mathbf{x} - \mathbf{x}_0) - c(\mathbf{v}_1 - \mathbf{v}_2)$$
                  </div>
              </div>
              
              <h4>Three Types of Springs</h4>
              <div class="spring-types">
                  <div class="spring-type">
                      <h5>1. Structural Springs</h5>
                      <p>Connect adjacent grid points to maintain fabric structure</p>
                      <p><strong>Stiffness:</strong> k_structural = 5000 N/m</p>
                      <p><strong>Damping:</strong> c_structural = 50 N¬∑s/m</p>
                  </div>
                  
                  <div class="spring-type">
                      <h5>2. Shearing Springs</h5>
                      <p>Connect diagonal grid points to prevent fabric deformation</p>
                      <p><strong>Stiffness:</strong> k_shearing = 5000 N/m</p>
                      <p><strong>Damping:</strong> c_shearing = 50 N¬∑s/m</p>
                  </div>
                  
                  <div class="spring-type">
                      <h5>3. Bending Springs</h5>
                      <p>Connect particles separated by one grid point to control fabric bending stiffness</p>
                      <p><strong>Stiffness:</strong> k_bending = 5000 N/m</p>
                      <p><strong>Damping:</strong> c_bending = 50 N¬∑s/m</p>
                  </div>
                            </div>
              
              <h4>Motion Equations and Integration</h4>
              <div class="formula-block">
                  <h5>Newton's Second Law</h5>
                  <p><strong>Motion Equation:</strong></p>
                  <div style="text-align: center; margin: 15px 0;">
                      $$m\mathbf{a} = \mathbf{F}_{total}$$
                      $$\mathbf{F}_{total} = \mathbf{F}_{spring} + \mathbf{F}_{damping} + \mathbf{F}_{gravity} + \mathbf{F}_{collision}$$
                  </div>
                  <ul>
                      <li>$m$: Particle mass</li>
                      <li>$\mathbf{a}$: Acceleration vector</li>
                                              <li>$\mathbf{F}_{gravity}$: Gravity $\mathbf{F}_g = m\mathbf{g}$</li>
                        <li>$\mathbf{F}_{collision}$: Collision force</li>
                  </ul>
              </div>
              
              <div class="demo-video">
                  <h4>Physics Collision Simulation Demo</h4>
                  <video controls width="100%" height="400">
                      <source src="Normal Gravity - Normal Collision.mp4" type="video/mp4">
                      Your browser does not support the video tag.
                  </video>
                  <p>Demonstration of our physics-based collision simulation system with spring dynamics and collision detection</p>
              </div>
              
            

            <h3>Sphere Ray Marching Algorithm</h3>
            <div class="algorithm-details">
                <h4>Core Algorithm Implementation</h4>
                <p>The sphere ray marching algorithm implements an efficient collision detection system that marches along a ray segment to find intersections with spherical surfaces. The algorithm uses signed distance fields (SDF) to determine the distance from any point to the sphere surface, enabling precise collision detection.</p>
                
                <h4>Mathematical Foundation</h4>
                <div class="formula-block">
                    <h5>Sphere SDF Function</h5>
                    <p><strong>Signed Distance Field:</strong></p>
                                      <div style="text-align: center; margin: 15px 0;">
                      $$\text{SDF}(\mathbf{p}) = ||\mathbf{p} - \mathbf{c}|| - r$$
                  </div>
                    <ul>
                        <li>$\mathbf{p}$: Point in 3D space</li>
                        <li>$\mathbf{c}$: Sphere center</li>
                        <li>$r$: Sphere radius</li>
                        <li>$\text{SDF}(\mathbf{p}) < 0$: Point inside sphere</li>
                        <li>$\text{SDF}(\mathbf{p}) = 0$: Point on sphere surface</li>
                        <li>$\text{SDF}(\mathbf{p}) > 0$: Point outside sphere</li>
                    </ul>
                </div>
                
                <div class="formula-block">
                    <h5>Ray Marching Algorithm</h5>
                    <p><strong>Ray Equation:</strong></p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$\mathbf{r}(t) = \mathbf{r}_0 + t \cdot \mathbf{d}, \quad t \in [0, L]$$
                    </div>
                    <p><strong>Marching Step:</strong></p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$\mathbf{p}_{i+1} = \mathbf{p}_i + \min(\Delta s, |\text{SDF}(\mathbf{p}_i)|) \cdot \mathbf{d}$$
                    </div>
                    <p><strong>Termination Condition:</strong></p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$|\text{SDF}(\mathbf{p}_i)| \leq \epsilon$$
                    </div>
                    <ul>
                        <li>$\mathbf{r}_0$: Ray origin (last position)</li>
                        <li>$\mathbf{d}$: Ray direction (normalized)</li>
                        <li>$L$: Ray length</li>
                        <li>$\epsilon$: Hit threshold ($10^{-6}$)</li>
                    </ul>
                </div>
                
                <h4>Key Features</h4>
                <ul>
                    <li><strong>Adaptive Step Size:</strong> Uses SDF value to determine optimal step size for efficient convergence</li>
                    <li><strong>Early Termination:</strong> Stops marching when surface is hit or maximum distance reached</li>
                    <li><strong>Fallback Detection:</strong> Checks endpoint if no collision found during marching</li>
                    <li><strong>Friction Integration:</strong> Applies frictional collision response with configurable coefficient</li>
                </ul>
                
                <div class="demo-image">
                    <h4>Basic Ray Marching Rendering</h4>
                    <img src="Camera-aware rendering.png" alt="Basic Ray Marching Rendering" width="100%" style="border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                    <p>Visualization of basic ray marching algorithm showing sphere intersection detection and surface rendering</p>
                </div>
            </div>

            <h3>Dynamic Object Collision Algorithm</h3>
            <div class="algorithm-details">
                <h4>Ray Marching Based Collision Detection</h4>
                <p>For dynamic objects composed of complex SDF geometries (such as moving spheres and boxes), we employ ray marching collision detection to avoid the computational overhead of repeatedly creating and updating mesh representations. This approach directly evaluates the signed distance field along particle trajectories.</p>
                
                <h5>Ray Marching Collision Detection</h5>
                <p>Pure ray marching approach that evaluates the signed distance field at each step along the ray. This method provides robust collision detection by marching along the particle's movement trajectory and checking for surface intersections. It uses adaptive stepping based on SDF gradients for optimal performance.</p>
                
                <div class="formula-block">
                    <h6>Ray Marching Process</h6>
                                            <p><strong>Marching Loop:</strong> For $i = 0$ to $N$:</p>
                    <ul>
                        <li>Current position: $\mathbf{p}_i = \mathbf{r}_0 + i \cdot \Delta s \cdot \mathbf{d}$</li>
                        <li>SDF evaluation: $\text{sdf}_i = \text{SDF}_{scene}(\mathbf{p}_i, t)$</li>
                        <li>Hit detection: if $|\text{sdf}_i| \leq \epsilon$, collision found</li>
                        <li>Adaptive step: $\text{step} = \min(\Delta s, |\text{sdf}_i|)$</li>
                    </ul>
                </div>
                
                <h3>Core Innovation: Dynamic Collision Detection System Based on SDF</h3>
                <p>Combine ray marching rendering with SDF (signed distance field) technology to achieve real-time collision detection between fabric and dynamic objects, 
                    using point cloud to represent the scene, without traditional mesh representation, significantly improving performance.</p>
    
    
    
                <h3>Advanced Collision Detection System</h3>
                <p>Implement seamless switching of three collision detection methods to ensure stability under high acceleration:</p>
                
                <h4>Collision Detection Physical Formulas</h4>
                <div class="formula-block">
                    <h5>Sphere Collision Detection</h5>
                    <p><strong>Distance Function:</strong></p>
                                      <div style="text-align: center; margin: 15px 0;">
                      $$d(\mathbf{p}, \text{sphere}) = ||\mathbf{p} - \mathbf{c}|| - r$$
                  </div>
                    <ul>
                        <li>$\mathbf{p}$: Particle position</li>
                        <li>$\mathbf{c}$: Sphere center position</li>
                        <li>$r$: Sphere radius</li>
                        <li>$d < 0$: Particle inside sphere</li>
                        <li>$d = 0$: Particle on sphere surface</li>
                        <li>$d > 0$: Particle outside sphere</li>
                    </ul>
                </div>
                
                <div class="formula-block">
                    <h5>Collision Response</h5>
                    <p><strong>Post-collision Position:</strong></p>
                                      <div style="text-align: center; margin: 15px 0;">
                      $$\mathbf{p}_{new} = \mathbf{c} + r \cdot \frac{\mathbf{p} - \mathbf{c}}{||\mathbf{p} - \mathbf{c}||}$$
                  </div>
                    <p><strong>Velocity Reflection:</strong></p>
                                      <div style="text-align: center; margin: 15px 0;">
                      $$\mathbf{v}_{new} = \mathbf{v} - 2(\mathbf{v} \cdot \mathbf{n})\mathbf{n}$$
                  </div>
                    <ul>
                        <li>$\mathbf{n}$: Collision point normal vector</li>
                        <li>$\mu$: Friction coefficient (usually $\mu = 0.3$)</li>
                    </ul>
                </div>
                
                <div class="formula-block">
                    <h5>Continuous Collision Detection (CCD)</h5>
                    <p><strong>Line-sphere intersection:</strong></p>
                    <p>Given line segment $\mathbf{p}_0 \rightarrow \mathbf{p}_1$ and sphere $(\mathbf{c}, r)$</p>
                                      <div style="text-align: center; margin: 15px 0;">
                      $$||\mathbf{p}_0 + t(\mathbf{p}_1 - \mathbf{p}_0) - \mathbf{c}||^2 = r^2$$
                  </div>
                    <p><strong>Trigger Condition:</strong></p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$L > 0.3R$$
                    </div>
                    <ul>
                        <li>$L$: Particle movement distance</li>
                        <li>$R$: Sphere radius</li>
                    </ul>
                </div>



                
                <h5>Dynamic Scene SDF</h5>
                <p>The dynamic scene combines multiple moving primitives using SDF union operations, creating complex geometries that change over time without requiring mesh regeneration.</p>
                
                <div class="formula-block">
                    <h6>Scene SDF Definition</h6>
                    <p><strong>Dynamic Scene:</strong></p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$\text{SDF}_{scene}(\mathbf{p}, t) = \min(\text{SDF}_{sphere}(\mathbf{p}, \mathbf{c}_{sphere}(t), r), \text{SDF}_{box}(\mathbf{p}, \mathbf{c}_{box}(t), \mathbf{b}))$$
                    </div>
                    <ul>
                        <li>$\mathbf{c}_{sphere}(t) = [\sin(0.5t) \cdot 2, 0, 0]$: Moving sphere center</li>
                        <li>$\mathbf{c}_{box}(t) = [\cos(0.5t) \cdot 2, 0, 0]$: Moving box center</li>
                        <li>$r = 1.0$: Sphere radius</li>
                        <li>$\mathbf{b} = [0.8, 0.8, 0.8]$: Box dimensions</li>
                    </ul>
                </div>
                
                <h5>Collision Response</h5>
                <p>When a collision is detected, the particle is projected to the surface using the SDF normal, and a frictional response is applied to maintain realistic physics behavior.</p>
                
                <div class="formula-block">
                    <h6>Surface Projection and Response</h6>
                    <p><strong>Surface Projection:</strong></p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$\mathbf{p}_{surface} = \mathbf{p}_{hit} - \text{SDF}(\mathbf{p}_{hit}) \cdot \frac{\nabla\text{SDF}(\mathbf{p}_{hit})}{||\nabla\text{SDF}(\mathbf{p}_{hit})||}$$
                    </div>
                    <p><strong>Collision Response:</strong></p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$\mathbf{p}_{new} = \mathbf{p}_{last} + (1-\mu) \cdot (\mathbf{p}_{surface} - \mathbf{p}_{last})$$
                    </div>
                    <ul>
                        <li>$\mu$: Friction coefficient ($0 \leq \mu \leq 1$)</li>
                        <li>$\mathbf{p}_{hit}$: Collision point</li>
                        <li>$\mathbf{p}_{surface}$: Projected surface position</li>
                    </ul>
                </div>
            </div>

            <h3>SDF Point Cloud Rendering</h3>
            <div class="algorithm-details">
                <h4>Dynamic Object Visualization</h4>
                <p>The SDF point cloud rendering system creates a visual representation of dynamic objects by sampling points near the surface and rendering them as colored spheres. This approach allows us to visualize complex dynamic geometries (such as moving spheres and boxes) without requiring traditional mesh generation, demonstrating how ray marching collision detection can avoid the computational overhead of repeatedly creating and updating mesh representations.</p>
                
                <h4>Mathematical Foundation</h4>
                <div class="formula-block">
                    <h5>Scene SDF Functions</h5>
                    <p><strong>Sphere SDF:</strong></p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$\text{SDF}_{sphere}(\mathbf{p}, \mathbf{c}, r) = ||\mathbf{p} - \mathbf{c}|| - r$$
                    </div>
                    <p><strong>Box SDF:</strong></p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$\text{SDF}_{box}(\mathbf{p}, \mathbf{c}, \mathbf{b}) = ||\max(|\mathbf{p} - \mathbf{c}| - \mathbf{b}, 0)|| + \min(\max(|\mathbf{p} - \mathbf{c}| - \mathbf{b}), 0)$$
                    </div>
                    <p><strong>Union Operation:</strong></p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$\text{SDF}_{union}(d_1, d_2) = \min(d_1, d_2)$$
                    </div>
                    <p><strong>Dynamic Scene:</strong></p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$\text{SDF}_{scene}(\mathbf{p}, t) = \min(\text{SDF}_{sphere}(\mathbf{p}, \mathbf{c}_{sphere}(t), r), \text{SDF}_{box}(\mathbf{p}, \mathbf{c}_{box}(t), \mathbf{b}))$$
                    </div>
                    <ul>
                        <li>$\mathbf{c}_{sphere}(t) = [\sin(0.5t) \cdot 2, 0, 0]$: Moving sphere center</li>
                        <li>$\mathbf{c}_{box}(t) = [\cos(0.5t) \cdot 2, 0, 0]$: Moving box center</li>
                        <li>$r = 1.0$: Sphere radius</li>
                        <li>$\mathbf{b} = [0.8, 0.8, 0.8]$: Box dimensions</li>
                    </ul>
                </div>
                
                <div class="formula-block">
                    <h5>SDF Normal Calculation</h5>
                    <p><strong>Finite Difference Method:</strong></p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$\nabla\text{SDF}(\mathbf{p}) \approx \begin{bmatrix}
                        \text{SDF}(\mathbf{p} + h \cdot \mathbf{i}) - \text{SDF}(\mathbf{p} - h \cdot \mathbf{i}) \\
                        \text{SDF}(\mathbf{p} + h \cdot \mathbf{j}) - \text{SDF}(\mathbf{p} - h \cdot \mathbf{j}) \\
                        \text{SDF}(\mathbf{p} + h \cdot \mathbf{k}) - \text{SDF}(\mathbf{p} - h \cdot \mathbf{k})
                        \end{bmatrix}$$
                    </div>
                    <p><strong>Normal Vector:</strong></p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$\mathbf{n} = \frac{\nabla\text{SDF}(\mathbf{p})}{||\nabla\text{SDF}(\mathbf{p})||}$$
                    </div>
                    <ul>
                        <li>$h = 10^{-4}$: Small perturbation</li>
                        <li>$\mathbf{i}, \mathbf{j}, \mathbf{k}$: Unit vectors in x, y, z directions</li>
                    </ul>
                </div>
                
                <h4>Sampling Strategies</h4>
                <ul>
                    <li><strong>Precise Surface Sampling:</strong> Samples points directly on primitive surfaces (spheres, boxes) with small random offsets to capture surface details</li>
                    <li><strong>Newton's Method Projection:</strong> Uses iterative surface projection to find precise surface points from random samples in space</li>
                    <li><strong>Adaptive Density:</strong> Concentrates samples in regions where SDF values are close to zero (near surfaces)</li>
                </ul>
                
                <div class="formula-block">
                    <h5>Newton's Method Surface Projection</h5>
                    <p><strong>Iterative Projection:</strong></p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$\mathbf{p}_{i+1} = \mathbf{p}_i - \text{SDF}(\mathbf{p}_i) \cdot \frac{\nabla\text{SDF}(\mathbf{p}_i)}{||\nabla\text{SDF}(\mathbf{p}_i)||^2}$$
                    </div>
                    <p><strong>Convergence Criterion:</strong></p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$|\text{SDF}(\mathbf{p}_i)| < \tau$$
                    </div>
                    <ul>
                        <li>$\mathbf{p}_0$: Initial random sample</li>
                        <li>$\tau = 0.02$: Surface proximity threshold</li>
                        <li>Max iterations: 5</li>
                    </ul>
                </div>
                
                <h4>Rendering Purpose</h4>
                <p>The point cloud rendering serves as a visualization tool to demonstrate the dynamic object's geometry and surface properties. By representing the complex SDF-based dynamic object (composed of moving spheres and boxes) as a collection of colored spheres, we can effectively visualize the collision surface without the computational burden of mesh generation. This approach highlights the efficiency of using ray marching for collision detection with dynamic objects.</p>
                
                <h4>Performance Optimizations</h4>
                <ul>
                    <li><strong>Adaptive Sampling:</strong> Concentrates samples near SDF surface for efficient visualization</li>
                    <li><strong>Early Exit:</strong> Stops sampling when sufficient surface points are found</li>
                    <li><strong>Color Coding:</strong> Visual distinction between inside/outside SDF regions using blue for interior and green for exterior</li>
                    <li><strong>Size Variation:</strong> Point size reflects distance to surface for better visual feedback</li>
                </ul>
            </div>
        </section>

        <section>
            <h2>Problems Encountered and Solutions</h2>
            
            <h3>1. Ray Marching Performance Optimization</h3>
            <p><strong>Problem:</strong> In the initial implementation, the number of steps in ray marching caused poor rendering performance.</p>
            <p><strong>Solution:</strong> By reducing the maximum number of steps (from 100 steps to 24 steps) and increasing the step length (from 0.02 to 0.15), performance is significantly improved while maintaining visual quality.</p>



            <h3>2. High-acceleration collision detection</h3>
            <p><strong>Problem:</strong> In high-acceleration situations, traditional collision detection tends to cause unreasonable bounces.</p>
            <p><strong>Solution:</strong> Implemented seamless switching of three collision detection methods: CCD (continuous collision detection), DCD (discrete collision detection), and ray marching collision detection.</p>

           

          
        </section>

        <section>
            <h2>Lessons Learned</h2>
            <div class="feature-grid">
                <div class="feature-card">
                    <h4>Physics Simulation</h4>
                    <p>Deep understanding of the principles and implementation details of the mass-spring model, mastering numerical integration and constraint processing techniques.</p>
                </div>
                <div class="feature-card">
                    <h4>Graphics Rendering</h4>
                    <p>Learned modern GPU rendering techniques, especially the implementation methods of ray marching and volume rendering.</p>
                </div>
                <div class="feature-card">
                    <h4>Performance Optimization</h4>
                    <p>Master the GPU computing optimization techniques, learn to find a balance between visual quality and performance.</p>
                </div>
                <div class="feature-card">
                    <h4>System Integration</h4>
                    <p>Learned to integrate different technical modules into a complete system, handling data transmission and synchronization between modules.</p>
                </div>
            </div>
        </section>

        <section>
            <h2>Final Results</h2>
            
            <h3>Core Demonstration Effects</h3>

            <h3>Collision Detection Method Comparison Demonstration</h3>
            
            <!-- Row 1: Normal Gravity Methods -->
            <div class="results-row">
                <div class="result-card">
                    <h4>Normal Gravity - Normal Collision</h4>
                    <div class="demo-video">
                        <h4>Normal Gravity - Normal Collision</h4>
                        <video controls width="100%" height="300">
                            <source src="Normal Gravity - Normal Collision.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <p>Fabric falls naturally, normal collision detection method</p>
                    </div>
                </div>
                
                <div class="result-card">
                    <h4>Normal Gravity - CCD Collision</h4>
                    <div class="demo-video">
                        <h4>Normal Gravity CCD Collision</h4>
                        <video controls width="100%" height="300">
                            <source src="Normal Gravity - CCD Collision.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <p>Fabric falls naturally, continuous collision detection method</p>
                    </div>
                </div>
                
                <div class="result-card">
                    <h4>Normal Gravity - Ray Marching Collision</h4>
                    <div class="demo-video">
                        <h4>Normal Gravity Ray Marching Collision</h4>
                        <video controls width="100%" height="300">
                            <source src="Normal Gravity - Ray Marching Collision.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <p>Fabric falls naturally, ray marching collision detection method</p>
                    </div>
                </div>
            </div>
            
            <!-- Row 2: 100x Gravity Methods -->
            <div class="results-row">
                <div class="result-card">
                    <h4>100x Gravity - Normal Collision</h4>
                    <div class="demo-video">
                        <h4>100x Gravity - Normal Collision</h4>
                        <video controls width="100%" height="300">
                            <source src="100x Gravity - Normal Collision.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <p>Fabric falls rapidly, normal collision detection method</p>
                    </div>
                </div>
                
                <div class="result-card">
                    <h4>100x Gravity - CCD Collision</h4>
                    <div class="demo-video">
                        <h4>100x Gravity CCD Collision</h4>
                        <video controls width="100%" height="300">
                            <source src="100x Gravity - CCD Collision.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <p>Fabric falls rapidly, continuous collision detection method</p>
                    </div>
                </div>
                
                <div class="result-card">
                    <h4>100x Gravity - Ray Marching Collision</h4>
                    <div class="demo-video">
                        <h4>100x Gravity Ray Marching Collision</h4>
                        <video controls width="100%" height="300">
                            <source src="100x Gravity - Ray Marching Collision.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <p>Fabric falls rapidly, ray marching collision detection method</p>
                    </div>
                </div>
            </div>
            
            <!-- Row 3: SDF Methods -->
            <div class="results-row">
                <div class="result-card">
                    <h4>SDF - Normal Collision (Fabric)</h4>
                    <div class="demo-video">
                        <h4>SDF Fabric Normal Collision</h4>
                        <video controls width="100%" height="300">
                            <source src="SDF - Normal Collision (Fabric).mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <p>SDF environment, fabric and structure normal collision detection</p>
                    </div>
                </div>
                
                
                
                <div class="result-card">
                    <h4>SDF - 100x Gravity Structure View</h4>
                    <div class="demo-video">
                        <h4>üå™Ô∏è SDF 100x Gravity Structure View</h4>
                        <video controls width="100%" height="300">
                            <source src="SDF - 100x Gravity Structure View.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <p>SDF environment, structure collision detection under 100x gravity</p>
                    </div>
                </div>
            </div>

            <div class="highlight">
                <strong>Technical Indicators:</strong>
                <ul>
                    <li>Support for 32x32 grid fabric simulation</li>
                    <li>SDF Dynamic Collision Detection: Spheres + Cubes Interact in Real-Time</li>
                    <li>Point Cloud Rendering: Dynamic Scene Display in Real-Time GUI</li>
    
                    <li>Collision Detection Comparison in Normal Gravity Environment</li>
                    <li>Robustness Test of Collision Detection in 100x Gravity Environment</li>
                    <li>Continuous Collision Detection (CCD) Stability Demonstration</li>
                    <li>Stable Collision Detection under High Acceleration</li>
                </ul>
            </div>

        </section>

  

        <section>
            <h2>Differences from References</h2>
            <ul>
                <li><strong>Real-time Performance:</strong> Optimized ray marching algorithm, achieving real-time interactive volume rendering</li>
                <li><strong>Extreme Gravity Test:</strong> Test the robustness of collision detection under 100x gravity, verify the stability of the ray marching method</li>
                <li><strong>CCD Integration:</strong> Integrated continuous collision detection, providing the most accurate collision detection solution</li>
                <li><strong>Ray Marching:</strong> Use ray marching to test collisions</li>
                <li><strong>SDF</strong> Use point clouds to simulate volume, thus achieving dynamic scene rendering</li>
            </ul>
        </section>



        <section class="team-section">
            <h2 style="color: white;">Contributions from each team member</h2>
            <div class="team-member">
                <h4>Isaac Gonzalez</h4>
                <p><strong>Main Contribution:</strong> Initial architecture construction of the project, research and test possibilities of specific directions. Slides and video production.</p>
            </div>
            <div class="team-member">
                <h4>Buqi Liao</h4>
                <p><strong>Main Contribution:</strong> Responsible for the core algorithm of fabric physics simulation, including mass-spring system, collision detection design, and writing ray marching, SDF rendering and collision detection.</p>
            </div>
            <div class="team-member">
                <h4>Alan Wang</h4>
                <p><strong>Main Contribution:</strong> Responsible for writing and testing collision detection design and ray marching rendering and collision detection, web design and summary.</p>
            </div>
            <div class="team-member">
                <h4>HeLin Zhou</h4>
                <p><strong>Main Contribution:</strong> Responsible for project management and document writing, as well as final effect testing and optimization. Slides and video production.</p>
            </div>
        </section>

        <section>
            <h2>References</h2>
            <div class="references">
                <ol>
                    <li>Schr√∂der, K., Klein, R., & Zinke, A. (2011). A Volumetric Approach to Predictive Rendering of Fabrics. Eurographics Symposium on Rendering 2011.</li>
                    <li>Zhao, S., Jakob, W., Marschner, S., & Bala, K. (2011). Building Volumetric Appearance Models of Fabric using Micro‚ÄëCT Imaging. ACM Transactions on Graphics (SIGGRAPH 2011).</li>
                    <li>Wikipedia. Volume ray casting / Ray marching.</li>
                    <li>Maxime Heckel. Real‚Äëtime Dreamy Cloudscapes with Volumetric Raymarching (2023).</li>
                    <li>Scratchapixel. Ray Marching: Getting it Right! ‚Äì Volume Rendering tutorial.</li>
                </ol>
            </div>
        </section>

        <footer>
            <p>¬© CS184 final project | UC Berkeley</p>
        </footer>
    </div>
</body>
</html>

